## 网络编程

#### 1.tcp&udp

```
tcp 字节流 stream socket  ip:poprt,ip:port
udp 数据保 datagrem socket
```

#### 2.port



#### 3.服务器怎么让客户端知道开放的端口，服务器端怎么选择端口？

```

```

#### 4.tcp三次握手

- ##### 服务端

  ```
  init 创建指定类型的套接字 tcp/udp/原始套接字
  bind 绑定IP port 端口设置为0 完全交给操作系统通过算法选择一个空闲端口 
  listen 转为被动套接字 监听等待请求
  accept 客户端请求到达，服务器应答成功，os将事件通知应用程序
  ```

  ```
  listen原型(
  listen int socketfd,int backlog)
  socketfd socket file description 套接字描述符
  backlog 未完成连接队列大小 理论并发数
  ```

  ```
  accept原型
  int accept(int listensockfd, struct sockaddr *cliaddr, socklen_t *addrlen)
  参数				初始化服务器端监听套接字  客户端地址 客户端地址大小
  建立连接，三次握手之后 
  生成一个已连接套接字 服务器使用这个已连接的套接字和客户端通信 
  完成通信 tcp连接释放 监听套接字继续监听，等待请求
  ```

- 客户端

  ```
  init 创建套接字
  connect 连接服务器
  int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen)
  参数        创建的套接字   套接字地址结构指针   结构长度
  连接之前不必bind ip port os 会确定ip port(找一个临时的)
  ```

- ##### tcp

  如果是tcp连接 客户端connect函数会触发三次握手

  ```
  三次握手实质是最少的次数确保在不可靠的信道中双方有能力完成通信
  ```

  客户端三次握手出错

  1. 客户端发送 SYN包无应答返回timeout 是客户端尝试多次后主动放弃连接

  2. 收到 RST 复位 客户端直接返回 connect refused

     ```
     RST 复位原因
     1. SYN 发送的端口未监听
     2. tcp 取消连接
     3. tcp 接收到一个根本不存在连接上的分支
     ```

  3. destination unreachable 双方路由不通

   

  ##### 三次握手过程

  握手过程是阻塞的，由os内核网络协议栈处理

  1. ```
     1. 客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 j ,客户端进入 SYNC_SENT 状态; 
     
     2. 服务器端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 j+1，表示 对 SYN 包 j 的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号 为 k，服务器端进入 SYNC_RCVD 状态; 
     ```

     ```
     1. 客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进行应答，应答数据为 k+1; 
     
     2. 应答包到达服务器端后，服务器端协议栈使得 accept 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 ESTABLISHED 状态。 
     ```

     